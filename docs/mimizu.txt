-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package mimizu
@version 0.1.0.0


module Mimizu.Chat

-- | The representation of one message
data Chat
Chat :: Origin -> UTCTime -> String -> String -> Chat

-- | The origin of message
[origin] :: Chat -> Origin

-- | The time (Internally in UTC, Externally in JST)
[time] :: Chat -> UTCTime

-- | The display name of sender the message sent by
[sender] :: Chat -> String

-- | The actual message
[message] :: Chat -> String

-- | The representation of origin where a message come from
data Origin

-- | NicoNico live stream. See
--   <a>http://com.nicovideo.jp/community/co3265652</a>
NicoNico :: Origin

-- | TUGame original site. See <a>http://tk2-217-18218.vs.sakura.ne.jp</a>
TUGame :: Origin

-- | YouTube live stream. See <a>https://www.youtube.com/user/TsUmezawa</a>
YouTube :: Origin

-- | convert origin to chat websocket acceptable string
toOriginString :: Origin -> String

-- | convert origin string to its Enum value
fromOriginString :: String -> Origin


module Mimizu.Util

-- | Convert from raw websocket data to Uint16
conv8To16 :: [Word8] -> Word16

-- | Convert from raw websocket data to Uint32
conv8To32 :: [Word8] -> Word32

-- | Convert from raw websocket data to Float
conv8To32f :: [Word8] -> Float

-- | Convert from raw websocket data to list of Uint16. Note: the length of
--   list must be multiple of 2.
conv8To16s :: [Word8] -> [Word16]

-- | Convert from Uint16 to sendable data
conv16To8 :: Word16 -> [Word8]

-- | Convert from Uint32 to sendable data
conv32To8 :: Word32 -> [Word8]

-- | Convert from Uint32 to Float
convToFloat :: Word32 -> Float

-- | The representation of color palette.
data Color

-- | The clolor of #3333ff
NeonBlue :: Color

-- | The clolor of #33bbff
SummerSky :: Color

-- | The clolor of #33ff33
LimeGreen :: Color

-- | The clolor of #33ffbb
Turquoise1 :: Color

-- | The clolor of #33eeee
Turquoise2 :: Color

-- | The clolor of #bb33ff
ElectricPurple :: Color

-- | The clolor of #bbbbee
LavenderGray :: Color

-- | The clolor of #bbff33
GreenYellow :: Color

-- | The clolor of #bbeebb
FringyFlower :: Color

-- | The clolor of #ff3333
RedOrange :: Color

-- | The clolor of #ff33bb
RazzleDazzleRose1 :: Color

-- | The clolor of #ee33ee
RazzleDazzleRose2 :: Color

-- | The clolor of #eeaa33
LightningYellow :: Color

-- | The clolor of #eebbbb
BeautyBush :: Color

-- | The clolor of #eeee33
GoldenFizz :: Color

-- | The clolor of #eeeeee
Whisper :: Color

-- | Convert Color to CSS acceptable string
colorToString :: Color -> String

-- | Convert css color hex-triplet to Color
fromStringToColor :: String -> Color

-- | Index type
type Index = Word32

-- | Convert Haskell Int to Word8
intToWord8 :: Int -> Word8

-- | Convert to Index type
integralToIndex :: Integral a => a -> Index

-- | Convert Text to list of Triplets
makeTriplets :: Text -> [(Index, String, [Color])]

-- | Convert framework color enum from string
makeColors :: String -> [Color]
instance GHC.Enum.Enum Mimizu.Util.Color


module Mimizu.Player

-- | The type of the length
type Length = Word32

-- | The representation of player
data Player
Player :: [Color] -> String -> Word32 -> Word16 -> [Word8] -> Player

-- | Skin information, a sequence of color
[skin] :: Player -> [Color]

-- | Name to be displayed
[name] :: Player -> String

-- | Counter to be shorten
[excreta] :: Player -> Word32

-- | Recent action
[act] :: Player -> Word16

-- | Joints and other info
[playerInfo] :: Player -> [Word8]

-- | A constructor-like function, compatibility for JS original source
createPlayer :: [Word8] -> Player

-- | The length and an air value of the player specified
getVA :: Player -> Word32

-- | The most recent action taken by the player specified
getAct :: Player -> Word16

-- | The current speed and `maximum speed` for the player specified
getSBM :: Player -> Word16

-- | The rough x-location, this function is only available when the
--   distance between you and the player specified is enough
getUSX :: Player -> Word16

-- | The rough y-location, this function is only available when the
--   distance between you and the player specified is enough
getUSY :: Player -> Word16

-- | the counter when the player specified is overlapping/overlapped by
--   other player. when this counter is enough, `going straight` bug will
--   occur.
getAir :: Player -> Word32

-- | The angle being aimed by the player specified
getAn :: Player -> Word16

-- | The flag whether dash button is been pressed by the player specified,
--   true if pressed
getBtn :: Player -> Bool

-- | Number of joints of the player specified
getJN :: Player -> Int32

-- | The <tt>gear</tt> the player currently in
getSH :: Player -> Float

-- | Current speed of the player specified
getSpd :: Player -> Word16

-- | The actual length the specified player has
getVol :: Player -> Word32

-- | The thickness of the player.
getSR :: Player -> Float

-- | Minimum turn radius
getTR :: Player -> Float

-- | The x location of head of the player specified. if it is too far,
--   return rough value by Left otherwise, return precise value by Right
getX0 :: Player -> Either Word16 Float

-- | The y location of head of the player specified. if it is too far,
--   return rough value by Left otherwise, return precise value by Right
getY0 :: Player -> Either Word16 Float

-- | Current Actual Head the player specified is going
getAngle :: Player -> Float

-- | The x location of idx-th joints of the player specified
getJointX :: Index -> Player -> Float

-- | The y location of index-th joints of the player specified
getJointY :: Index -> Player -> Float

-- | Size convert function from the length
sizeR :: Length -> Float

-- | Compatibility function for getJointX and getJointY
getX :: Index -> Player -> Float

-- | Compatibility function for getJointX and getJointY
getY :: Index -> Player -> Float

-- | The helper function for <a>MutablePlayerList</a>, it will modify the
--   player info.
modifyPlayerInfo :: [Word8] -> Maybe Player -> Maybe Player

-- | The helper function for <a>MutablePlayerList</a>, it will modify the
--   action.
modifyAction :: Word16 -> Maybe Player -> Maybe Player

-- | The helper function for <a>MutablePlayerList</a>, it will modify the
--   excreta
modifyExcreta :: Word32 -> Maybe Player -> Maybe Player

-- | The helper function for <a>MutablePlayerList</a>, it will modify the
--   name
modifyName :: String -> Maybe Player -> Maybe Player

-- | The helper function for <a>MutablePlayerList</a>, it will modify the
--   skin
modifySkin :: [Color] -> Maybe Player -> Maybe Player


module Mimizu.Food

-- | The food info contained by one block.
newtype FoodBlock
FoodBlock :: [Word8] -> FoodBlock
[foodInfo] :: FoodBlock -> [Word8]

-- | color to be displayed
getColor :: Index -> FoodBlock -> Color

-- | size you can aquire when you eat, also size to be displayed
getSize :: Index -> FoodBlock -> Word8

-- | x location of the food specified by index and food block
getFoodX :: Index -> FoodBlock -> Word8

-- | y location of the food specified by index and food block
getFoodY :: Index -> FoodBlock -> Word8

-- | compatibility funcction for getFoodX and getFoodY
getX :: Index -> FoodBlock -> Word8

-- | compatibility funcction for getFoodX and getFoodY
getY :: Index -> FoodBlock -> Word8


module Mimizu


module Framework

-- | The destination IP address the socket connects to, in the form of
--   Word8 quadruplet.
hostAddress :: (Word8, Word8, Word8, Word8)

-- | Convert Word8 quadruple to host string.
toAddrString :: (Word8, Word8, Word8, Word8) -> String

-- | The port number the socket accepts.
gamePort :: PortNumber

-- | The port number the socket accepts.
chatPort :: PortNumber

-- | The callback function, this is called when message from
--   <a>gamePort</a>.
type GameReceiveCallback = Index  The index of player you are currently playing. -> [(Index, Maybe Player)]  Current list of players, which may not be updated depending on the distance from you. -> [(Index, FoodBlock)]  Current list of food blocks, which may not be updated for the block where the block you are not in. -> (DashFlag, GameAngle)  The action you intend to be taken.
type GameAngle = Word16  Must be in range 0 ~ 4096.
type DashFlag = Bool  True if dash is on, False otherwise.

-- | A list/map of players, Nothing if the player for that Index is not
--   being played/dead.
type MutablePlayerList = [(Index, IORef (Maybe Player))]

-- | A list/map of foods, Index represents the block.
type MutableFoodList = [(Index, IORef FoodBlock)]

-- | Your ID for playing, the index is the key of MutablePlayerList.
type PlayerID = IORef Index

-- | Convert to websocket acceptable form.
convertToSendable :: (DashFlag, GameAngle) -> ByteString
run :: GameReceiveCallback -> ClientApp ()
mainLoop :: GameReceiveCallback -> IO ()

-- | Convert mutable list/map to immutable
pullIORefs :: [(Index, IORef a)] -> IO [(Index, a)]

-- | Remove IORef out of the argument.
eliminateIORef :: (Index, IORef a) -> IO (Index, a)

-- | Modify player list using parsed player other info for the specific
--   plaeyr
parsePlayer :: MutablePlayerList -> Index -> [Word8] -> IO ()

-- | Modify player list using pased action binary data for the specific
--   player
parseAction :: MutablePlayerList -> Index -> [Word8] -> IO ()

-- | Modify player list using parsed death info
parseDeath :: MutablePlayerList -> Index -> IO ()

-- | Modify food list using parsed food info.
parseFood :: MutableFoodList -> Index -> [Word8] -> IO ()

-- | Modify ist using parsed index value
parseNumber :: IORef Index -> Word8 -> IO ()

-- | A tag for parsing data.
playerParseTag :: Word8

-- | A tag for parsing data.
actionParseTag :: Word8

-- | A tag for parsing data.
foodParseTag :: Word8

-- | A tag for parsing data.
deathParseTag :: Word8

-- | A tag for parsing data.
numberParseTag :: Word8

-- | parse binary data from <tt>gameSocket</tt>.
parseGameData :: PlayerID -> MutablePlayerList -> MutableFoodList -> [Word8] -> IO ()

-- | parse text data from <tt>gameSocket</tt>
parseSkinData :: MutablePlayerList -> Text -> IO ()
